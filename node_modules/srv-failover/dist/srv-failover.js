// Generated by CoffeeScript 1.12.6
(function() {
  var SrvFailover, _, httpDNS, url,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  httpDNS = require('http-dns');

  url = require('url');

  _ = {
    difference: require('lodash/difference'),
    first: require('lodash/first'),
    map: require('lodash/map'),
    pull: require('lodash/pull'),
    sortBy: require('lodash/sortBy')
  };

  SrvFailover = (function() {
    function SrvFailover(arg, arg1) {
      var domain, protocol, service;
      domain = arg.domain, protocol = arg.protocol, service = arg.service, this.urlProtocol = arg.urlProtocol;
      this.dns = (arg1 != null ? arg1 : {}).dns;
      this._noValidAddressesError = bind(this._noValidAddressesError, this);
      this.resolveUrl = bind(this.resolveUrl, this);
      this.markGoodUrl = bind(this.markGoodUrl, this);
      this.markBadUrl = bind(this.markBadUrl, this);
      this.clearBadUrls = bind(this.clearBadUrls, this);
      if (domain == null) {
        throw new Error('Missing required parameter: domain');
      }
      if (protocol == null) {
        throw new Error('Missing required parameter: protocol');
      }
      if (service == null) {
        throw new Error('Missing required parameter: service');
      }
      this.badUrls = [];
      this.hostname = "_" + service + "._" + protocol + "." + domain;
      if (this.dns == null) {
        this.dns = httpDNS;
      }
      if (this.urlProtocol == null) {
        this.urlProtocol = protocol;
      }
    }

    SrvFailover.prototype.clearBadUrls = function() {
      return this.badUrls = [];
    };

    SrvFailover.prototype.markBadUrl = function(badUrl, arg) {
      var ttl;
      ttl = (arg != null ? arg : {}).ttl;
      this.badUrls.push(badUrl);
      if (ttl != null) {
        return setTimeout(((function(_this) {
          return function() {
            return _this.markGoodUrl(badUrl);
          };
        })(this)), ttl);
      }
    };

    SrvFailover.prototype.markGoodUrl = function(goodUrl) {
      return _.pull(this.badUrls, goodUrl);
    };

    SrvFailover.prototype.resolveUrl = function(callback) {
      return this.dns.resolveSrv(this.hostname, (function(_this) {
        return function(error, addresses) {
          var allUrls, theUrl;
          if (error != null) {
            return callback(error);
          }
          allUrls = _.map(_.sortBy(addresses, 'priority'), function(address) {
            return url.format({
              protocol: _this.urlProtocol,
              hostname: address.name,
              port: address.port,
              slashes: true
            });
          });
          theUrl = _.first(_.difference(allUrls, _this.badUrls));
          if (theUrl == null) {
            return callback(_this._noValidAddressesError());
          }
          return callback(null, theUrl);
        };
      })(this));
    };

    SrvFailover.prototype._noValidAddressesError = function() {
      var error;
      error = new Error('SRV record found, but contained no valid addresses');
      error.noValidAddresses = true;
      return error;
    };

    return SrvFailover;

  })();

  module.exports = SrvFailover;

}).call(this);

//# sourceMappingURL=srv-failover.js.map
