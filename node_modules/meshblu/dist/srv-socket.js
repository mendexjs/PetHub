// Generated by CoffeeScript 1.12.6
(function() {
  var Backoff, ProxySocket, SrvFailover, SrvSocket, _, url,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Backoff = require('backo');

  _ = require('lodash');

  SrvFailover = require('srv-failover');

  url = require('url');

  ProxySocket = require('./proxy-socket');

  SrvSocket = (function(superClass) {
    extend(SrvSocket, superClass);

    function SrvSocket(arg, dependencies) {
      var domain, hostname, port, protocol, resolveSrv, secure, service, socketIoOptions, srvProtocol, urlProtocol;
      protocol = arg.protocol, hostname = arg.hostname, port = arg.port, service = arg.service, domain = arg.domain, secure = arg.secure, resolveSrv = arg.resolveSrv, socketIoOptions = arg.socketIoOptions;
      this.dependencies = dependencies != null ? dependencies : {};
      this._resolveUrlFromAddresses = bind(this._resolveUrlFromAddresses, this);
      this._resolveUri = bind(this._resolveUri, this);
      this._getSrvProtocol = bind(this._getSrvProtocol, this);
      this._getSrvConnectionProtocol = bind(this._getSrvConnectionProtocol, this);
      this._getSrvAddress = bind(this._getSrvAddress, this);
      this.send = bind(this.send, this);
      this.connect = bind(this.connect, this);
      this.close = bind(this.close, this);
      this._options = {
        protocol: protocol,
        hostname: hostname,
        port: port,
        service: service,
        domain: domain,
        secure: secure,
        resolveSrv: resolveSrv
      };
      this._socketIoOptions = _.defaults({}, socketIoOptions, {
        forceNew: true,
        reconnection: false
      });
      this.backoff = new Backoff;
      if (!resolveSrv) {
        return;
      }
      srvProtocol = 'socket-io-wss';
      urlProtocol = 'wss';
      if (secure === false) {
        srvProtocol = 'socket-io-ws';
        urlProtocol = 'ws';
      }
      this._srvFailover = new SrvFailover({
        domain: domain,
        service: service,
        protocol: srvProtocol,
        urlProtocol: urlProtocol
      }, {
        dns: this.dependencies.dns
      });
    }

    SrvSocket.prototype.close = function(callback) {
      if (this._socket == null) {
        return callback();
      }
      this._socket.once('disconnect', (function(_this) {
        return function() {
          return callback();
        };
      })(this));
      return this._socket.close();
    };

    SrvSocket.prototype.connect = function(callback) {
      var _socketIoClient, ref, socketIoClient;
      if (callback != null) {
        throw new Error('connect should not take a callback');
      }
      delete require.cache[require.resolve('socket.io-client')];
      socketIoClient = require('socket.io-client');
      _socketIoClient = (ref = this.dependencies.socketIoClient) != null ? ref : socketIoClient;
      return this._resolveUri((function(_this) {
        return function(error, uri) {
          if (error != null) {
            return _this.emit('resolve-uri:error', error);
          }
          _this._socket = _socketIoClient(uri, _this._socketIoOptions);
          _this._socket.once('connect', function() {
            return _this.backoff.reset();
          });
          _this._socket.once('connect_error', function(error) {
            var backoff;
            if (_this._srvFailover != null) {
              _this._srvFailover.markBadUrl(uri, {
                ttl: 60000
              });
            }
            backoff = _this.backoff.duration();
            return _.delay(_this.connect, backoff);
          });
          return _this._proxyDefaultIncomingEvents();
        };
      })(this));
    };

    SrvSocket.prototype.send = function() {
      var ref;
      if (this._socket != null) {
        return (ref = this._socket).emit.apply(ref, arguments);
      }
    };

    SrvSocket.prototype._getSrvAddress = function() {
      var domain, protocol, ref, service;
      ref = this._options, service = ref.service, domain = ref.domain;
      protocol = this._getSrvProtocol();
      return "_" + service + "._" + protocol + "." + domain;
    };

    SrvSocket.prototype._getSrvConnectionProtocol = function() {
      if (this._options.secure) {
        return 'wss';
      }
      return 'ws';
    };

    SrvSocket.prototype._getSrvProtocol = function() {
      if (this._options.secure) {
        return 'socket-io-wss';
      }
      return 'socket-io-ws';
    };

    SrvSocket.prototype._resolveUri = function(callback) {
      var hostname, port, protocol, ref;
      ref = this._options, protocol = ref.protocol, hostname = ref.hostname, port = ref.port;
      if (this._srvFailover == null) {
        return callback(null, url.format({
          protocol: protocol,
          hostname: hostname,
          port: port,
          slashes: true
        }));
      }
      return this._srvFailover.resolveUrl((function(_this) {
        return function(error, baseUrl) {
          if (error && error.noValidAddresses) {
            _this._srvFailover.clearBadUrls();
            return _this._resolveUri(callback);
          }
          if (error != null) {
            return callback(error);
          }
          return callback(null, baseUrl);
        };
      })(this));
    };

    SrvSocket.prototype._resolveUrlFromAddresses = function(addresses) {
      var address;
      address = _.minBy(addresses, 'priority');
      return url.format({
        protocol: this._getSrvConnectionProtocol(),
        hostname: address.name,
        port: address.port,
        slashes: true
      });
    };

    return SrvSocket;

  })(ProxySocket);

  module.exports = SrvSocket;

}).call(this);

//# sourceMappingURL=srv-socket.js.map
